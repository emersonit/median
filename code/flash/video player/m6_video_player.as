package  {		import flash.external.*;	import flash.display.*;	import flash.events.*;	import flash.media.*;	import flash.utils.*;	import flash.text.*;	import flash.net.*;	import flash.ui.*;	import fl.controls.*;	import fl.video.*;		/*			MEDIAN 6 DYNAMIC VIDEO PLAYER YAY			notes				- limited keyboard in fullscreen: http://helpx.adobe.com/flash-player/kb/limited-full-screen-keyboard-input.html		- dynamic streaming class docs: http://www.adobe.com/devnet/adobe-media-server/articles/dynstream_advanced_pt2.html		- actionscript 3 reference: http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/		*/		public class m6_video_player extends MovieClip {				// jeepers, look at all of these variables		private var debug:Boolean = false;		private var control_padding:int = 5;		private var show_debug_info:Boolean = true;		private var src_url:String = '';		private var permalink:String = 'https://median.emerson.edu/';		private var median_id:int;		private var server_url:String;		private var streams:Array;		private var stream_is_live:Boolean = false;		private var autoplay:Boolean = false;		private var loop:Boolean = false;		private var captions:Array;		private var has_captions:Boolean = false;		private var show_captions:Boolean = false;		private var show_buttons_in_fullscreen:Boolean = true;		private var video_ready:Boolean = false;		private var video_metadata:Object;		private var is_clip:Boolean = false;		private var clip_start:Number;		private var clip_end:Number;		private var clip_duration:Number;		private var currently_buffering:Boolean = false;		private var currently_playing:Boolean = false;		private var play_started_once:Boolean = false;		private var previous_volume:Number = 1;		private var poster_loader:Loader;		private var video:Video;		private var seek_bar_current_width:Number = 100;		private var buffering_sprite:Sprite;		private var buffering_text:TextField;		private var caption_sprite:Sprite;		private var caption_text:TextField;		private var median_btn:Sprite;		private var median_text:TextField;		private var time_sprite:Sprite;		private var time_text:TextField;		private var seek_time_sprite:Sprite;		private var seek_time_text:TextField;		private var error_text:TextField;		private var error_text_format:TextFormat;		private var video_status_timer:Timer;		private var video_status_timer_interval:Number = 250; // in milliseconds		private var nc:NetConnection;		private var ds:DynamicStream;		private var dsi:DynamicStreamItem;		private var ds_sound:SoundTransform;		private var seek_bar_original_width:Number;		private var volume_bar_original_width:Number;		private var mouse_is_idle:Boolean = false;		private var mouse_last_pos:Object = { x: 0, y: 0 };		private var mouse_idle_so_far:Number = 0;		private var mouse_idle_timeout:Number = 3000; // in milliseconds				// let's get this party started		public function m6_video_player() {						// set up default scale mode stuff			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			stage.addEventListener(Event.RESIZE, resize_handler);			stage.addEventListener(KeyboardEvent.KEY_UP, keyboard_handler);						// get these for use later			seek_bar_original_width = seek_bar_base.width;			volume_bar_original_width = volume_bar_base.width;						// buttons should be invisible			//hide_controls();			playpause_btn.pause_mc.visible = false;						// set all of this nonsense to make the buttons actually buttons			bigplay_btn.mouseChildren = false;			bigplay_btn.buttonMode = true;			playpause_btn.mouseChildren = false;			playpause_btn.buttonMode = true;			mute_btn.mouseChildren = false;			mute_btn.buttonMode = true;			cc_btn.mouseChildren = false;			cc_btn.buttonMode = true;			fs_btn.mouseChildren = false;			fs_btn.buttonMode = true;						// make the timecode textfield			time_sprite = new Sprite();			time_text = new TextField();			time_text.text = '00:00/00:00';			time_text.selectable = false;			time_text.autoSize = TextFieldAutoSize.LEFT;			time_text.background = true;			time_text.backgroundColor = 0x000000;			var timecode_format:TextFormat = new TextFormat();			timecode_format.font = "Courier New";			timecode_format.color = 0xFFFFFF;			timecode_format.size = 12;			time_text.defaultTextFormat = timecode_format;			time_text.setTextFormat(timecode_format);			time_sprite.addChild(time_text);			//time_sprite.visible = false;			stage.addChild(time_sprite);						// make the seek bar timecode textfield			seek_time_sprite = new Sprite();			seek_time_text = new TextField();			seek_time_text.selectable = false;			seek_time_text.autoSize = TextFieldAutoSize.LEFT;			seek_time_text.background = true;			seek_time_text.backgroundColor = 0x000000;			var seek_timecode_format:TextFormat = new TextFormat();			seek_timecode_format.font = "Courier New";			seek_timecode_format.color = 0xFFFFFF;			seek_timecode_format.size = 12;			seek_time_text.defaultTextFormat = seek_timecode_format;			seek_time_text.setTextFormat(seek_timecode_format);			seek_time_sprite.addChild(seek_time_text);			seek_time_sprite.visible = false;			stage.addChild(seek_time_sprite);						// special "median" button stuff			buffering_sprite = new Sprite();			buffering_text = new TextField();			buffering_text.selectable = false;			buffering_text.text = 'buffering...';			buffering_text.autoSize = TextFieldAutoSize.LEFT;			buffering_text.background = true;			buffering_text.backgroundColor = 0x000000;			var buffering_text_format:TextFormat = new TextFormat();			buffering_text_format.font = "Verdana";			buffering_text_format.color = 0xFFFFFF;			buffering_text_format.size = 12;			buffering_text.defaultTextFormat = buffering_text_format;			buffering_text.setTextFormat(buffering_text_format);			buffering_sprite.addChild(buffering_text);			buffering_sprite.visible = false;			stage.addChild(buffering_sprite);						// caption text field stuff			caption_sprite = new Sprite();			caption_sprite.x = 10;			caption_sprite.y = 10;			caption_text = new TextField();			caption_text.text = '';			caption_text.selectable = false;			caption_text.autoSize = TextFieldAutoSize.LEFT;			caption_text.background = true;			caption_text.backgroundColor = 0x000000;			caption_text.wordWrap = false;			var caption_text_format:TextFormat = new TextFormat();			caption_text_format.font = "Verdana";			caption_text_format.color = 0xFFFFFF;			caption_text_format.size = 16;			caption_text.defaultTextFormat = caption_text_format;			caption_text.setTextFormat(caption_text_format);			caption_sprite.addChild(caption_text);			caption_sprite.visible = false;			stage.addChild(caption_sprite);						// buffering text stuff			median_btn = new Sprite();			median_text = new TextField();			median_text.text = 'median';			median_text.selectable = false;			median_text.autoSize = TextFieldAutoSize.LEFT;			median_text.background = true;			median_text.backgroundColor = 0x000000;			var median_text_format:TextFormat = new TextFormat();			median_text_format.font = "Verdana";			median_text_format.color = 0xFFFFFF;			median_text_format.size = 12;			median_text.defaultTextFormat = median_text_format;			median_text.setTextFormat(median_text_format);			median_btn.addChild(median_text);			median_btn.mouseChildren = false;			median_btn.buttonMode = true;			median_btn.addEventListener(MouseEvent.CLICK, median_btn_handler);			median_btn.x = stage.stageWidth - median_btn.width - control_padding;			median_btn.y = stage.stageHeight - control_padding - median_btn.height - 2;			stage.addChild(median_btn);						// set up the error text display, should we need it			error_text = new TextField();			error_text.autoSize = TextFieldAutoSize.CENTER;			error_text.background = true;			error_text.backgroundColor = 0x000000;			error_text_format = new TextFormat();			error_text_format.font = "Verdana";			error_text_format.color = 0xFFFFFF;			error_text_format.size = 18;			error_text.defaultTextFormat = error_text_format;			error_text.setTextFormat(error_text_format);						// look for flashvars/params			// these will tell the player what to actually do			var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters;						if (flashvars.hasOwnProperty('debug')) {				debug = true;			}						if (flashvars.hasOwnProperty('src')) {				// the URL to a JSON file with connection info				src_url = flashvars.src;			} else {				if (debug) {					// for debugging...					src_url = 'http://no.dev.emerson.edu/test/m6_video/video-test.json';					//src_url = 'http://no.dev.emerson.edu/test/m6_video/live-test.json';					//src_url = 'http://no.dev.emerson.edu/test/m6_video/audio-test.json';					//autoplay = true;				} else {					set_error_text('No source provided, not sure what to play.');				}			}						if (flashvars.hasOwnProperty('ap')) {				// autoplay?				if (flashvars.ap == '1') {					autoplay = true;				} else if (flashvars.ap == '0') {					autoplay = false;				}			}						if (flashvars.hasOwnProperty('loop')) {				// autoplay?				if (flashvars.loop == '1') {					loop = true;				} else if (flashvars.loop == '0') {					loop = false;				}			}						if (flashvars.hasOwnProperty('cc')) {				// auto-display captions if available?				if (flashvars.cc == '1') {					show_captions = true;				} else if (flashvars.cc == '0') {					show_captions = false;				}			}						cc_btn.on_mc.visible = show_captions;						if (flashvars.hasOwnProperty('fsbtns')) {				// show buttons in fullscreen? yes or no.				if (flashvars.fsbtns == '1') {					show_buttons_in_fullscreen = true;				} else if (flashvars.fsbtns == '0') {					show_buttons_in_fullscreen = false;				}			}						// get the video info (or error) based on "src_url" variable			if (src_url != '') {				var src_req:URLRequest = new URLRequest(src_url);				var src_loader:URLLoader = new URLLoader();				src_loader.addEventListener(Event.COMPLETE, info_load_complete_handler);				src_loader.load(src_req); // this sets off the actual process				// make sure everything looks nice and tight after all that has been set up				keep_things_sized_right();			} else {				trace('NOTHING TO DO'); // we're stuck if this happens, but that's okay				// an error will be on screen right now			}						// add external interface for javascript			ExternalInterface.addCallback('get_current_time', get_current_time);			ExternalInterface.addCallback('get_duration', get_duration);			// called from flash to javascript:			// onPlayerCreated(playerId), onCurrentTimeChange(time, playerId), onDurationChange(time, playerId)			ExternalInterface.call('onPlayerCreated', ExternalInterface.objectID);		}				// handle external javascript calls for info		public function get_current_time():Number {			if (play_started_once) {				if (is_clip) {					return ds.time - clip_start;				} else {					return ds.time;				}			} else {				return 0;			}		}				public function get_duration():Number {			if (is_clip) {				return clip_duration;			} else if (video_metadata != null) {				return video_metadata.duration;			} else {				return 0;			}		}				// send the browser to the permalink if clicked		private function median_btn_handler(e:MouseEvent):void {			navigateToURL(new URLRequest(permalink), "_top");		}				// show a nice big error message		private function set_error_text(message:String):void {			error_text.text = message; // set the message			// keep it in the middle			error_text.x = (stage.stageWidth / 2) - error_text.textWidth/2;			error_text.y = (stage.stageHeight / 2) - error_text.textHeight/2;			// if the error text has never been added to the stage, add it			if (stage.contains(error_text) == false) {				stage.addChild(error_text);			} else {				error_text.visible = true;			}			// make sure the error text is on top			error_text.parent.setChildIndex(error_text, error_text.parent.numChildren - 1);			hide_controls();		}				// really kick things off when the media info loads		private function info_load_complete_handler(e:Event):void {			var result:String = e.target.data;			//trace(result);						// try parsing it as JSON			try {				var media_info:Object = JSON.parse(result);			} catch (e:Error) {				// failed, there was a problem!				set_error_text("There was an error parsing the media information.");				return;			}			if (media_info.hasOwnProperty('error')) {				// oh no! stop everything!				trace('there was an ERROR from the media info JSON');				trace(media_info.error);				set_error_text(media_info.error);			} else {				// worked! nice								// if there is a "permalink" attribute, use it				if (media_info.hasOwnProperty('permalink') && media_info.permalink != '') {					permalink = media_info.permalink;				}								// if there is a "poster" attribute, use it				if (media_info.hasOwnProperty('poster') && media_info.poster != '') {					trace('loading poster: ' + media_info.poster);					poster_loader = new Loader();					poster_loader.x = 0;					poster_loader.y = 0;					poster_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, poster_loaded_handler);					stage.addChild(poster_loader);					poster_loader.load(new URLRequest(media_info.poster));				}								// if there is a "captions" attribute, use it				if (media_info.hasOwnProperty('captions') && media_info.captions != '') {					trace('loading captions: ' + media_info.captions);					var captions_req:URLRequest = new URLRequest(media_info.captions);					var captions_loader:URLLoader = new URLLoader();					captions_loader.addEventListener(Event.COMPLETE, captions_loaded_handler);					captions_loader.load(captions_req); // this sets off the actual process				}								// if there is a "clip" attribute, use it				if (media_info.hasOwnProperty('clip_start') && media_info.hasOwnProperty('clip_end')) {					is_clip = true;					clip_start = media_info.clip_start;					clip_end = media_info.clip_end;					clip_duration = clip_end - clip_start;				}								// there has to be at least these				if (media_info.hasOwnProperty('server') == false || media_info.hasOwnProperty('type') == false || media_info.hasOwnProperty('streams') == false) {					set_error_text("There was inadequate information to start your video, sorry.");				} else {					// use this info for our streaming connection					server_url = media_info.server;					if (media_info.type == 'live') {						stream_is_live = true;					}					streams = media_info.streams;					// good to go -- set up the connection					setup_connection();				}			}		}				// deal with captions loading		private function captions_loaded_handler(e:Event):void {			var result:String = e.target.data;			//trace(result);						// try parsing it as JSON			try {				var captions_obj:Object = JSON.parse(result);			} catch (e:Error) {				// failed, there was a problem!				set_error_text("There was an error parsing the captions.");				return;			}			if (captions_obj.hasOwnProperty('captions') && captions_obj.captions.length > 0) {				has_captions = true;				captions = captions_obj.captions;				//trace(captions);			}		}				// poster was loaded? great, show it.		private function poster_loaded_handler(e:Event):void {			trace('putting up the poster!');						// get the image data itself for reference			var image_data:DisplayObject = poster_loader.content;						// scale the image to the max it can while preserving the aspect ratio			var width_scale = to_fixed(stage.stageWidth/image_data.width, 3);			var height_scale = to_fixed(stage.stageHeight/image_data.height, 3);			if (width_scale > height_scale) {				// adjust video.y so the video is in the middle				poster_loader.width = image_data.width * height_scale;				poster_loader.height = image_data.height * height_scale;				poster_loader.x = (stage.stageWidth - poster_loader.width) / 2;				poster_loader.y = 0;			} else {				// adjust video.x so the video is in the middle				poster_loader.width = image_data.width * width_scale;				poster_loader.height = image_data.height * width_scale;				poster_loader.x = 0;				poster_loader.y = (stage.stageHeight - poster_loader.height) / 2;			}			// make sure the big play button stays on top of the poster			poster_loader.parent.setChildIndex(poster_loader, 0);		}				// this function actually starts the streaming connection		private function setup_connection():void {			// set up the video element now that we can proceed			video = new Video(stage.stageWidth, stage.stageHeight);			video.x = 0;			video.y = 0;			video.smoothing = true;			video_hit.addEventListener(MouseEvent.CLICK, video_click_handler);			stage.addChild(video); // attach it to the stage			video.parent.setChildIndex(video, 0); // make sure it's kept in the "background" so controls can be over it			// set up netconnection			nc = new NetConnection();			nc.addEventListener(NetStatusEvent.NET_STATUS, netstatus_handler);			nc.addEventListener(AsyncErrorEvent.ASYNC_ERROR, async_error_handler);			nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, security_error_handler);			nc.addEventListener(IOErrorEvent.IO_ERROR, io_error_handler);			nc.connect(server_url); // once connected, the stream will start		}				// this function actually starts the streaming itself		private function setup_stream():void {						trace('setting up dynamic stream!');						// new dynamic stream, oh yeah! even if it's not actually a dynamic stream			ds = new DynamicStream(nc);						ds.addEventListener(NetStatusEvent.NET_STATUS, netstatus_handler);			ds.addEventListener(AsyncErrorEvent.ASYNC_ERROR, async_error_handler);			ds.addEventListener(SecurityErrorEvent.SECURITY_ERROR, security_error_handler);			ds.addEventListener(IOErrorEvent.IO_ERROR, io_error_handler);						// this weird intermediary "client" object thing is necessary			var ds_client_obj:Object = new Object();			ds_client_obj.onMetaData = metadata_handler;			ds_client_obj.onPlayStatus = play_status_handler;			ds_client_obj.onSeekPoint = seek_point_handler;			ds_client_obj.onBWCheck = bwcheck_handler;			ds_client_obj.onBWDone = bwdone_handler;			ds.client = ds_client_obj;						// basic settings for the dynamic stream			ds.startBufferLength = 1;			ds.preferredBufferLength = 5;			ds.aggressiveModeBufferLength = 2;						// the sound control			ds_sound = new SoundTransform(1);			ds.soundTransform = ds_sound;						// set up the actual dynamic stream path info			dsi = new DynamicStreamItem();						// do different stuff if stream is LIVE			if (stream_is_live) {				trace('live stream!');				dsi.start = -1; // use this if it's a live stream				autoplay = true; // just play it!				hide_controls();			}						// load up the different video versions			for (var i:int = 0; i < streams.length; i++) {				trace('new stream: ' + streams[i].path);				dsi.addStream(streams[i].path, streams[i].bitrate);			}						// set a decent start rate, but it'll ratchet up if it can, automatically			dsi.startRate = 696;						// okay set up buttons yay now that we have video			bigplay_btn.addEventListener(MouseEvent.CLICK, bigplay_btn_handler);			playpause_btn.addEventListener(MouseEvent.CLICK, playpause_btn_handler);			mute_btn.addEventListener(MouseEvent.CLICK, mute_btn_handler);			cc_btn.addEventListener(MouseEvent.CLICK, cc_btn_handler);			fs_btn.addEventListener(MouseEvent.CLICK, fs_btn_handler);						// attach that stream to that video!			video.attachNetStream(ds);						// okay we're all ready here			video_ready = true;						// if autoplay, then get started, duh!			if (autoplay) {				currently_buffering = true;				ds.startPlay(dsi);				play_started_once = true;				if (is_clip) {					ds.seek(clip_start);				}			} else {				// display big play button, if not autoplay				bigplay_btn.visible = true;			}						// start the timer to check on video status / timecode / etc			video_status_timer = new Timer(video_status_timer_interval);			video_status_timer.addEventListener(TimerEvent.TIMER, video_status_timer_handler);            video_status_timer.start();					}				// handle what happens when clicking on the video		private function video_click_handler(e:MouseEvent):void {			if (currently_playing) {				pause_video();			} else {				play_video();			}		}				// handle what happens when clicking the big play button		private function bigplay_btn_handler(e:MouseEvent):void {			play_video();		}				// handle what happens when clicking the play/pause button		private function playpause_btn_handler(e:MouseEvent):void {			if (currently_playing) {				pause_video();			} else {				play_video();			}		}				// the function that actually deals with playing the video		private function play_video():void {			if (play_started_once == false) {				ds.startPlay(dsi);				play_started_once = true;				show_controls();				seek_bar_hit.addEventListener(MouseEvent.CLICK, seek_bar_click_handler);				seek_bar_hit.addEventListener(MouseEvent.MOUSE_MOVE, seek_bar_move_handler);				seek_bar_hit.addEventListener(MouseEvent.MOUSE_OUT, seek_bar_out_handler);				volume_bar_hit.addEventListener(MouseEvent.CLICK, volume_bar_click_handler);				keep_things_sized_right();				if (is_clip) {					ds.seek(clip_start);				}			} else {				ds.resume();			}			if (poster_loader != null && stage.contains(poster_loader)) {				stage.removeChild(poster_loader);			}			playpause_btn.play_mc.visible = false;			playpause_btn.pause_mc.visible = true;			bigplay_btn.visible = false;		}				// the function that actually deals with pausing the video		private function pause_video():void {			ds.pause();			playpause_btn.play_mc.visible = true;			playpause_btn.pause_mc.visible = false;			bigplay_btn.visible = true;		}				// handle what happens when someone clicks the mute button		private function mute_btn_handler(e:MouseEvent):void {			toggle_mute();		}				private function toggle_mute():void {			if (ds_sound.volume > 0) {				previous_volume = ds_sound.volume;				ds_sound.volume = 0;				mute_btn.off_mc.visible = false;				mute_btn.on_mc.visible = true;			} else {				ds_sound.volume = previous_volume;				mute_btn.off_mc.visible = true;				mute_btn.on_mc.visible = false;			}			ds.soundTransform = ds_sound;		}				// handle what happens when someone clicks the closed-captioning button		private function cc_btn_handler(e:MouseEvent):void {			toggle_captions();		}				// toggle captions, if they're even available		private function toggle_captions():void {			if (has_captions) {				if (show_captions) {					show_captions = false;				} else {					show_captions = true;				}				cc_btn.on_mc.visible = show_captions;				cc_btn.off_mc.visible = !show_captions;			}		}				// handle what happens when someone clicks the fullscreen button		private function fs_btn_handler(e:MouseEvent):void {			toggle_fullscreen();		}				// toggle fullscreen		private function toggle_fullscreen():void {			if (stage.displayState == StageDisplayState.NORMAL) {				stage.displayState = StageDisplayState.FULL_SCREEN;			} else {				stage.displayState = StageDisplayState.NORMAL;			}			keep_things_sized_right();		}				// this goes off every X milliseconds once the video starts to update the timecode, the seek bar, and other stuff		private function video_status_timer_handler(e:TimerEvent):void {			// don't bother doing this if the connection/stream are null for some reason			if (nc == null || ds == null) {				return;			}						// update debug text, if enabled			if (show_debug_info && play_started_once && video_metadata != null) {				debug_txt_label.visible = true;				debug_txt_label.text = '';				//debug_txt_label.text += 'Max Bandwidth: ' + to_fixed(ds.maxBandwidth, 2) + "\n";				debug_txt_label.text += 'Player size: ' + stage.stageWidth + 'x' + stage.stageHeight + "\n";				debug_txt_label.text += 'Video size: ' + video_metadata.width + 'x' + video_metadata.height + "\n";				if (stream_is_live) {					debug_txt_label.text += 'Buffer time: ' + ds.bufferLength + "\n";				} else {					debug_txt_label.text += 'Playhead time: ' + ds.time + '/' + video_metadata.duration + "\n";				}				debug_txt_label.text += 'Current Stream Bitrate: ' + ds.currentStreamBitRate + "\n";				debug_txt_label.text += 'Current Actual Total Kbps: ' + to_fixed(ds.info.currentBytesPerSecond/1024, 2) + "\n";				debug_txt_label.text += 'Current Actual Audio Kbps: ' + to_fixed(ds.info.audioBytesPerSecond/1024, 2) + "\n";				debug_txt_label.text += 'Current Actual Video Kbps: ' + to_fixed(ds.info.videoBytesPerSecond/1024, 2) + "\n";			} else {				debug_txt_label.visible = false;			}						// update certain video controls			buffering_sprite.visible = currently_buffering;						// update the seek bar progress			if (play_started_once && video_metadata != null) {				if (is_clip) {					seek_bar_progress.width = ((ds.time - clip_start) / clip_duration) * seek_bar_current_width;					ExternalInterface.call('onCurrentTimeChange', (ds.time - clip_start), ExternalInterface.objectID);				} else {					seek_bar_progress.width = (ds.time / video_metadata.duration) * seek_bar_current_width;					ExternalInterface.call('onCurrentTimeChange', ds.time, ExternalInterface.objectID);				}			} else {				seek_bar_progress.width = 0;			}						// show some captions based on current time			if (play_started_once && has_captions && show_captions) {				var found_caption:Boolean = false;				for (var i:int = 0; i < captions.length; i++) {					if (ds.time >= captions[i].start_secs && ds.time <= captions[i].end_secs) {						found_caption = true;						caption_text.htmlText = captions[i].text;						//trace('caption textWidth: ' + caption_text.textWidth);						trace('caption width: ' + caption_text.width);						trace('stageWidth: ' + stage.stageWidth);						if (caption_text.width >= stage.stageWidth * 0.75 - 20) {							trace('too big, sizing it to fit');							caption_text.wordWrap = true;							caption_text.width = stage.stageWidth * 0.75;						} else {							trace('its fine, leaving it alone');							caption_text.wordWrap = false;							//caption_text.width = caption_text.textWidth;						}					}				}				caption_sprite.visible = found_caption;			} else {				caption_sprite.visible = false;			}						// update timecode			if (play_started_once && video_metadata != null) {				if (is_clip) {					time_text.text = convert_secs_to_timecode(ds.time - clip_start) + '/' + convert_secs_to_timecode(clip_duration);				} else {					time_text.text = convert_secs_to_timecode(ds.time) + '/' + convert_secs_to_timecode(video_metadata.duration);				}			}						// don't show any error messages if we're actually playing something			if (currently_playing && error_text != null && stage.contains(error_text) == true) {				error_text.visible = false;			}						// do some mouse tracking			if (play_started_once) {				//trace('tracking mouse: ' + mouseX + ', ' + mouseY);				if (mouse_last_pos.x == mouseX && mouse_last_pos.y == mouseY) {					//trace('same mouse pos as last time!');					mouse_idle_so_far += video_status_timer_interval;					if (mouse_idle_so_far > mouse_idle_timeout) {						//trace('hiding controls!');						mouse_is_idle = true;						hide_controls();						Mouse.hide();					}				} else {					//trace('mouse pos changed!');					mouse_idle_so_far = 0;					mouse_is_idle = false;					show_controls();					mouse_last_pos.x = mouseX;					mouse_last_pos.y = mouseY;					Mouse.show();				}			}						// make sure everything is sized right			keep_things_sized_right();			        }				// function to hide all of the controls		private function hide_controls():void {			skin_bg.visible = false;			seek_bar_base.visible = false;			seek_bar_progress.visible = false;			playpause_btn.visible = false;			mute_btn.visible = false;			cc_btn.visible = false;			fs_btn.visible = false			volume_bar_base.visible = false;			volume_bar_progress.visible = false;			volume_bar_hit.visible = false;			debug_txt_label.visible = debug;			if (median_btn != null && stage.contains(median_btn)) {				median_btn.visible = false;			}			if (time_sprite != null && stage.contains(time_sprite)) {				time_sprite.visible = false;			}		}				// function to show all of the controls		private function show_controls():void {			if (!stream_is_live) {				seek_bar_base.visible = true;				seek_bar_progress.visible = true;				playpause_btn.visible = true;				cc_btn.visible = has_captions;				if (time_sprite != null && stage.contains(time_sprite)) {					time_sprite.visible = true;				}			}			skin_bg.visible = true;			debug_txt_label.visible = debug;			fs_btn.visible = true;			mute_btn.visible = true;			volume_bar_base.visible = true;			volume_bar_progress.visible = true;			volume_bar_hit.visible = true;			if (median_btn != null && stage.contains(median_btn)) {				median_btn.visible = true;			}		}				// handle what happens when someone clicks on the seek bar		private function seek_bar_click_handler(e:MouseEvent):void {			if (!play_started_once || !currently_playing) {				return;			}			if (video_metadata == null) {				return;			}			trace('seek bar clicked!');			var seek_point:Number = e.localX;			// e.localX will be between 0 and 10			if (seek_point > 10) {				seek_point = 10;			} else if (seek_point < 0) {				seek_point = 0;			}			var seek_to:Number = 0;			if (is_clip) {				seek_to = clip_start + ((seek_point/seek_bar_original_width) * clip_duration);			} else {				seek_to = (seek_point/seek_bar_original_width) * video_metadata.duration;			}			trace('seeking to ' + seek_to);			ds.seek(seek_to);		}				// handle moving the mouse over the seek bar		private function seek_bar_move_handler(e:MouseEvent):void {			if (video_metadata == null) {				return;			}			var seek_point:Number = e.localX;			// e.localX will be between 0 and 10			if (seek_point > 10) {				seek_point = 10;			} else if (seek_point < 0) {				seek_point = 0;			}			var seek_to:Number = 0;			if (is_clip) {				seek_to = clip_start + ((seek_point/seek_bar_original_width) * clip_duration);			} else {				seek_to = (seek_point/seek_bar_original_width) * video_metadata.duration;			}			seek_time_sprite.visible = true;			seek_time_sprite.x = seek_bar_base.x + ((seek_point/seek_bar_original_width) * seek_bar_base.width) - (seek_time_sprite.width/2);			seek_time_sprite.y = seek_bar_base.y - seek_time_sprite.height;			if (is_clip) {				seek_time_text.text = convert_secs_to_timecode((seek_point/seek_bar_original_width) * clip_duration);			} else {				seek_time_text.text = convert_secs_to_timecode(seek_to);			}			//trace('hovering over ' + convert_secs_to_timecode(seek_to));		}				// handle moving the mouse out away from the seek bar		private function seek_bar_out_handler(e:MouseEvent):void {			seek_time_sprite.visible = false;		}				// handle what happens when someone clicks on the volume bar		private function volume_bar_click_handler(e:MouseEvent):void {			trace('volume bar clicked!');			var volume_point:Number = e.localX;			if (volume_point > 10) {				volume_point = 10;			} else if (volume_point < 0) {				volume_point = 0;			}			ds_sound.volume = volume_point / volume_bar_original_width;			trace('new volume: ' + ds_sound.volume);			ds.soundTransform = ds_sound;			volume_bar_progress.width = volume_bar_base.width * ds_sound.volume;		}				// helper function to convert seconds to pretty timecode		private function convert_secs_to_timecode(s:Number):String {			var formatted:String = '';			s = Math.round(s);			var hours:int = Math.floor(s / 60 / 60);			var minutes:int = Math.floor((s / 60) % 60);			var seconds:int = s % 60;			var secondsTenths:int = (Math.round(seconds * 10) % 600)/10;			if (hours > 0) {				formatted += hours + ':';			}			if (minutes < 10) {				formatted += '0';			}			formatted += minutes;			formatted += ':';			if (seconds < 10) {				formatted += '0';			}			formatted += seconds;			return formatted;		}				// handle any status events from the netstream and netconnection		private function netstatus_handler(e:NetStatusEvent):void {			trace('== net status incoming!');			trace(e.info.code);			switch (e.info.code) {				case 'NetConnection.Connect.Success':				setup_stream();				break;				case 'NetConnection.Connect.Closed':				set_error_text("There was an error playing the stream, please try again.");				video_status_timer.stop();				break;				case 'NetStream.Play.Start':				currently_playing = true;				trace('New Stream Bitrate: ' + ds.currentStreamBitRate);				break;				case 'NetStream.Play.Stop':				//currently_playing = false;				break;				case 'NetStream.Pause.Notify':				currently_playing = false;				break;				case 'NetStream.Unpause.Notify':				currently_playing = true;				break;				case 'NetStream.Buffer.Full':				currently_buffering = false;				break;				case 'NetStream.Buffer.Empty':				currently_buffering = true;				break;				case 'NetStream.SeekStart.Notify':				currently_buffering = true;				break;				case 'NetStream.Seek.Notify':				currently_buffering = true;				break;				case 'NetStream.Seek.Complete':				currently_buffering = false;				currently_playing = true;				break;				case 'NetStream.Play.StreamNotFound':				if (stream_is_live) {					set_error_text("The selected stream was not found, sorry.");					video_status_timer.stop();				} else {					// not sure what to do with VOD stuff, since it could still be working if 1 stream isn't found				}				break;			}		}				// handle any async errors from the netstream/netconnection		private function async_error_handler(e:AsyncErrorEvent):void {			trace('== async error!');			trace_object(e);		}				// handle any security errors from the netstream/netconnection		private function security_error_handler(e:NetStatusEvent):void {			trace('== net status incoming!');			trace(e.info.code);		}				// handle any IO errors from the netstream/netconnection		private function io_error_handler(e:AsyncErrorEvent):void {			trace('== io error!');			trace_object(e);		}				// this function is called whenever the video metadata comes back		private function metadata_handler(meta:Object):void {			trace('== metadata incoming!');			trace_object(meta);			video_metadata = meta;			ExternalInterface.call('onDurationChange', video_metadata.duration, ExternalInterface.objectID);			keep_things_sized_right();		}				// this function is called whenever there's some kind of "play status" update		private function play_status_handler(e:Object):void {			trace('== play status incoming!');			trace_object(e);			switch (e.code) {				case 'NetStream.Play.Complete':				ds.seek(0);				if (!loop) {					currently_playing = false;					pause_video();				}				break;			}		}				// does this actually ever happen? a seek point event notification? i don't know.		private function seek_point_handler(e:Object):void {			trace('== seek point info incoming!');			trace_object(e);		}				// this is for weird flash media server compatibility		private function bwcheck_handler(... rest):Number {			return 0;		}				// this is for weird flash media server compatibility		private function bwdone_handler(... rest):void {			// lol		}				// function that keeps all of the elements on the player in the right places and pretty		private function keep_things_sized_right():void {			// keep video full size, poster, too			// keep controls in the right places						if (stage.stageWidth < 250 || stage.stageHeight < 250) {				return;			}						var width_scale:Number = 0;			var height_scale:Number = 0;						// big play button in the center			if (bigplay_btn != null && stage.contains(bigplay_btn)) {				bigplay_btn.x = (stage.stageWidth/2) - (bigplay_btn.width/2);				bigplay_btn.y = (stage.stageHeight/2) - (bigplay_btn.height/2);			}						// for the poster			if (poster_loader != null && stage.contains(poster_loader)) {				var image_data:DisplayObject = poster_loader.content;				width_scale = to_fixed(stage.stageWidth/image_data.width, 3);				height_scale = to_fixed(stage.stageHeight/image_data.height, 3);				if (width_scale > height_scale) {					// adjust video.y so the video is in the middle					poster_loader.width = image_data.width * height_scale;					poster_loader.height = image_data.height * height_scale;					poster_loader.x = (stage.stageWidth - poster_loader.width) / 2;					poster_loader.y = 0;				} else {					// adjust video.x so the video is in the middle					poster_loader.width = image_data.width * width_scale;					poster_loader.height = image_data.height * width_scale;					poster_loader.x = 0;					poster_loader.y = (stage.stageHeight - poster_loader.height) / 2;				}			}						// for video, use video_metadata vs stage.stageWidth/stage.stageHeight			if (video != null && stage.contains(video) && video_metadata != null) {				width_scale = to_fixed(stage.stageWidth/video_metadata.width, 3);				height_scale = to_fixed(stage.stageHeight/video_metadata.height, 3);				if (width_scale > height_scale) {					// adjust video.y so the video is in the middle					video.width = video_metadata.width * height_scale;					video.height = video_metadata.height * height_scale;					video.x = (stage.stageWidth - video.width) / 2;					video.y = 0;				} else {					// adjust video.x so the video is in the middle					video.width = video_metadata.width * width_scale;					video.height = video_metadata.height * width_scale;					video.x = 0;					video.y = (stage.stageHeight - video.height) / 2;				}				video_hit.x = video.x;				video_hit.y = video.y;				video_hit.width = video.width;				video_hit.height = video.height;			}									// buffering bar stays in the top right			buffering_sprite.x = stage.stageWidth - control_padding - buffering_sprite.width;			buffering_sprite.y = control_padding;						// the background skin stays along the bottom			skin_bg.height = control_padding + playpause_btn.height + control_padding;			skin_bg.width = stage.stageWidth;			skin_bg.x = 0;			skin_bg.y = stage.stageHeight - skin_bg.height;						// make sure controls are in the right place			// use control_padding between controls			// from left to right						// play/pause button "sticks" to the bottom-left			playpause_btn.x = control_padding;			playpause_btn.y = stage.stageHeight - control_padding - playpause_btn.height;						// seek bar x is relative to play/pause button,			// but its width expands...			seek_bar_base.x = playpause_btn.x + playpause_btn.width + control_padding;			seek_bar_base.y = stage.stageHeight - control_padding - seek_bar_base.height - 6;			seek_bar_progress.x = seek_bar_base.x;			seek_bar_progress.y = seek_bar_base.y;			seek_bar_hit.x = seek_bar_base.x;			seek_bar_hit.y = seek_bar_base.y;						// median button "sticks" to the bottom-right			median_btn.x = stage.stageWidth - median_btn.width - control_padding;			median_btn.y = stage.stageHeight - control_padding - median_btn.height - 2;						// and the other controls fill in that space			// so do the rest right-to-left			cc_btn.x = median_btn.x - cc_btn.width - control_padding;			cc_btn.y = stage.stageHeight - control_padding - cc_btn.height;						fs_btn.x = cc_btn.x - fs_btn.width - control_padding;			fs_btn.y = stage.stageHeight - control_padding - fs_btn.height;						volume_bar_base.width = 50;			volume_bar_hit.width = volume_bar_base.width;			if (ds_sound != null) {				volume_bar_progress.width = volume_bar_base.width * ds_sound.volume;			} else {				volume_bar_progress.width = volume_bar_base.width;			}			volume_bar_base.x = fs_btn.x - volume_bar_base.width - control_padding;			volume_bar_progress.x = volume_bar_base.x;			volume_bar_hit.x = volume_bar_base.x;			volume_bar_base.y = stage.stageHeight - control_padding - volume_bar_base.height - 6;			volume_bar_progress.y = volume_bar_base.y;			volume_bar_hit.y = volume_bar_base.y;			mute_btn.x = volume_bar_base.x - mute_btn.width - control_padding;			mute_btn.y = stage.stageHeight - control_padding - mute_btn.height;						time_sprite.x = mute_btn.x - time_sprite.width - control_padding;			time_sprite.y = stage.stageHeight - control_padding - time_sprite.height - 2;						seek_bar_current_width = time_sprite.x - control_padding - seek_bar_base.x;			seek_bar_base.width = seek_bar_current_width;			seek_bar_hit.width = seek_bar_current_width;						bigplay_btn.visible = !currently_playing;						cc_btn.on_mc.visible = show_captions;			cc_btn.off_mc.visible = !show_captions;						if (has_captions && show_captions) {				caption_sprite.x = (stage.stageWidth / 2) - (caption_sprite.width / 2);				caption_sprite.y = playpause_btn.y - (control_padding * 2) - caption_sprite.height;			}						if (stage.displayState == StageDisplayState.FULL_SCREEN) {				fs_btn.on_mc.visible = false;				fs_btn.off_mc.visible = true;			} else {				fs_btn.on_mc.visible = true;				fs_btn.off_mc.visible = false;			}						if (stage.displayState == StageDisplayState.FULL_SCREEN && show_buttons_in_fullscreen == false) {				hide_controls();			} else if (show_buttons_in_fullscreen && play_started_once && !mouse_is_idle) {				show_controls();			}		}				private function keyboard_handler(e:KeyboardEvent):void {			//trace('key pressed: ' + e.keyCode);			if (!video_ready) {				return;			}			switch (e.keyCode) {				case 32: // spacebar -- play/pause				case 80: // p -- play/pause				if (!stream_is_live) {					if (currently_playing) {						pause_video();					} else {						play_video();					}				}				break;				case 70: // f -- forward 10 seconds				if (play_started_once && !stream_is_live) {					if (is_clip) {						if (ds.time + 10 < clip_end) {							ds.seek(ds.time + 10);						}					} else {						if (ds.time + 10 < video_metadata.duration) {							ds.seek(ds.time + 10);						}					}					trace('jumping forward 10 seconds');				}				break;				case 82: // r -- back 10 seconds				if (play_started_once && !stream_is_live) {					if (is_clip) {						if (ds.time - 10 > clip_start) {							ds.seek(ds.time - 10);						} else {							ds.seek(0);						}					} else {						if (ds.time - 10 > 0) {							ds.seek(ds.time - 10);						} else {							ds.seek(0);						}					}					trace('jumping backwards 10 seconds');				}				break;				case 88: // x -- fullscreen				toggle_fullscreen();				break;				case 67: // c -- caption toggle				if (!stream_is_live) {					toggle_captions();				}				break;				case 77: // m -- mute				toggle_mute();				break;				case 85: // u -- volume up 10%				ds_sound.volume += 0.1;				if (ds_sound.volume > 1) {					ds_sound.volume = 1;				}				ds.soundTransform = ds_sound;				break;				case 68: // d -- volume down 10%				ds_sound.volume -= 0.1;				if (ds_sound.volume < 0) {					ds_sound.volume = 0;				}				ds.soundTransform = ds_sound;				break;				case 90: // z -- debug mode				if (debug) {					debug = false;				} else {					debug = true;				}				break;			}		}				// this is triggered every time the player is resized		private function resize_handler(e:Event):void {			keep_things_sized_right();		}				// helper function to make dealing with weird floating point numbers easier		private function to_fixed(num:Number, precision:int):Number {			precision = Math.pow(10, precision);			return Math.round(num * precision)/precision;		}				// helper function to trace-out object properties sometimes		private function trace_object(obj:Object) {			for (var id:String in obj) {				var value:Object = obj[id];				trace(id + " = " + value);			}		}			} // that's all!	}